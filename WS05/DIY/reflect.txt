While working on Workshop 5, I have learned many new topics and at the same time went through few difficulties. The topics that I have learned through the LAB and the DIY sections of Workshop 5 were the "member operators" and "helper functions". When working on the workshop, the keyword "operator" allows the other programmer and myself to understand that the operator's symbol that came after the keyword was going to be overloaded. When overloading operators, the format of overloading is "(className)& operator(operator's symbol) (const (className)&)". Many operators can be overloaded, but there are symbols that can not be overloaded and they are: "scope resolution operator (::)", "member selection operator (.)", "member selection through a pointer to a member operator (.*)", and "conditional operator (?:)". When identifying operators, they can be classified by a number of operands they take. When one operand is taken, the operator is known as a "unary". the operator is can be seen as "binary" if two operands were taken, and finally, "ternary" when three operands were taken. Moreover, Workshop 5 had got me to overload the operators in two different methods: through "member operators" and "helper operators". Member operators have direct access to the class members, whereas helper operators do not have direct access to the representation, but the role of the helper operator is to support the class. Throughout the LAB and the DIY, I have used many binary operators, such as "Account& operator= (int integerValue);" and "Mark& operator= (int newMark);" and also the unary operators, such as "operator int()const;" and "operator double()const;". 

Helper functions were also implemented in the LAB and the DIY. Helper functions are functions that collect information from the public member functions of the class. Hence, the helper functions are not able to access the private members of the class. In order for the helper functions to access the private members, the private functions are to be implemented within the helper functions. However, there is one method to get the helper functions to access the private members by using the friendship keyword "friend". Thus, the format of the helper function with the friendship is "friend Type identifier(type [, type, ...]);". I have used the friendship method in both LAB and DIY to make the helper function more efficient, such as "friend double operator+ (const Account& mainAccount, const Account& anotherAccount);" and "friend int operator+= (int& newMark, const Mark& finalMark);". 

The LAB and DIY from the workshop had given me few challenges, but they are manageable to tackle. At first, I was confused about formatting the overloading operators, but the notes are given by professor Hong and the recorded lecture got me to understand the concept. Another challenge I was facing was whether to use friendship or not in my helper functions because the helper functions had run well without the friendship. However, I chose to use the friendship because it was easier to access the private members and the code looked neater than without using the friendship. Therefore, through Workshop 5, I was able to learn many different topics through the notes, recorded lectures, and the difficulties I have gone through. 