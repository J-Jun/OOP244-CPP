==============================================
Name:           Jason Jun
Student Number: 126 683 200
Email:          jjun10@myseneca.ca
Section:        OOP244 NCC
Workshop:       Workshop 10 - Reflection
==============================================

When working on Workshop 10, I had to deal with the "Rule of Three" in both different modules. Rule of three contained all the definitions of "copy constructor", "copy assignment operator", and "destructor". When implementing the rule of three in the base class, there was no difference from the regular constructor, copy assignment and destructor. However, when getting into the derived class, which is the "HtmlText module", I had to implement the rule of three along with the base class. When the copy constructor was created, I also had to call the constructor of the base class. Hence, the copy constructor of the derived class is written in a form of "Derived(const Derived& identifier) : Base(identifier) { ... }". For example, in the workshop, I had to write the copy construct form in the format, "HtmlText::HtmlText(const HtmlText& h_text) : Text(h_text) { ... }". The logic behind the copy constructor of the derived class is to copy the base class part and the derived part of the existing object. The copy assignment and the destructor had similar logic as the ones in the base class. Not only the rule of three was implemented, but the overloading and the overriding topics were used. Both of these topics were already been implemented in the previous workshops and were not a new topic I had interacted with. I had used the insertion overload in the "Text" module, "std::ostream& operator<<(std::ostream& ostr, const Text& text)" and the overloading the "write" function in the "HtmlText" module, "void write(std::ostream& os)const;". When working on this workshop, I still had some trouble handling text files, but from the experience of working on Workshop 6, I was able to burden off the problem. Other than that, I did not really have any problems. 

In the same week of doing Workshop 10, I have also worked on Milestone 5. Milestone 5 is where I had to reuse functions from different classes that were made from different Milestones. However, when working on the milestone, I have learned about initializing the member variables in a similar format of inheritance of the derived class. If the member variable is "in m_variable", it can be initialized in the constructor, such as "newClass(int i) : m_variable(i) { ... }". When working on Milestone 5, I only had trouble implementing the logic behind some functions and had to debug to understand how my logic was going through and detect errors.