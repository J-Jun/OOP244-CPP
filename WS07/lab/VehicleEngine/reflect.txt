==============================================
Name:           Jason Jun
Student Number: 126 683 200
Email:          jjun10@myseneca.ca
Section:        OOP244 NCC
Workshop:       Workshop 7 - Reflection
==============================================

	While working on Workshop 7, I have learned about many different topics, but also went through difficulties that were resolved. When I needed to reuse a constructor from a different class, I had to go through an inheritance. Inheritance is a relationship between classes, where one class receives or is able to use the entire structure of another class. Inheritance is a transitive structural relationship, but not commutative. When inheritance is used in a hierarchy, there are two classes where a class with a lower hierarchy is a kind of class that is higher in the hierarchy. Hence, the lower class can be seen as a child and the class at the higher hierarchy is a parent, so it can be seen as a parent class passing down the structure of itself to the child class. The child class in the is a kind of relationship can be also be called as a "derived class" and the parent class in the relationship as a "base class". In a diagram, the derived class is at a lower hierarchy or level than the parent class. In object-oriented languages, these two classes have equivalent terms, where the base class is called as a superclass and parent class, and derived class as a subclass, heir class, and child class. 

	When the derived class inherits, it contains the instance variables and the other normal member functions of the base class and includes derive class's own instance variables and functions. However, the normal member functions of the base class exclude the special member functions, where the functions are constructors, destructors, or assignment operators. When the derived class is implemented in the source code, it takes the form of "class Derived : access Base { }", where "Derived" is replaced with the derived class' name and the "Base" is replaced with the base class' name. "access" is seen as access that the derived class has to the non-private members of the base class. The default access to the base class is the "private" and the most common access is the "public". The C++ language support three different types of access to the member class and they are: "private" (bars all access), "protected" (limits access to derived classes only), and "public" (unlimited access). When using the member functions from the base class, the format of writing is "Derived::member function()", where the "member function" is replaced with the member function's name from the base class. In the workshop, I have also used this format of the programming when I had to inherit a MotorVehicle class to the Truck class: "Truck::Truck(const char* licenseNumber, int manufactureYear, double truckCapacity, const char* currentAddress) : MotorVehicle(licenseNumber, manufactureYear)". By doing this, I was able to hold information about the motor vehicle that can carry cargo. When granting protected access, there could be a security hole where any data member that is granted the protected access could be exposed to corruption. Thus, the protected design is poor. To make sure the design is good, it is recommended to keep a data member private and have it accessible through a protected query. 

	When the base class inherits the member functions of the base class, it can also be seen as the base class "shadowing" the base class member functions. In order to access the base class, the derived had shadowed its member functions, the scope resolution is used. To call the shadowed functions, the following format of programming is used, "Base::identifier(arguments)" where the "Base" refers to the class where the shadowed class came from. "using" declaration is inserted into the definition of the derived class to expose overloaded member functions. Hence, the "using" declaration takes the form of "using Base::identifier;", where the "Base" is the base class and "identifier" refers to the shadowed function's name. When the constructor is brought up, a derived class does not inherit a base class' constructor by default. Hence, the compiler will insert a constructor with no argument by default if a constructor is not declared in the derived class. The compiler constructs an instance of the derived class in four steps, but in 2 significant stages: 

			1. Construct the base class portion of the complete object
				1. Allocate memory for the instance variables in the order of their declaration
				2. Execute the base class constructor
			2. Construct the derived class portion of the object
				3. Allocate memory for the instance variables in the order of their declaration
				4. Execute the derived class constructor
	
	When passing arguments to the base class constructor, it takes the form of "Derived( parameters ) : Base( arguments )", where "Derived" is the name of the derived class and the "Base" is the name of the base class. This form is also used in workshop 7 as mentioned before. A derived class does not inherit the destructor from a base class and the destructors act in the opposite order of the constructor. The derived class destructor always executes before the base class destructor. Moreover, the helper functions from a base class do not support the classes derived from the supported base class. 

	Not only did I have worked on Workshop 7, but I also worked on Milestone 1 and 2. While working on Milestone 1, input and outputs were used and I have learned new functions that I have implemented into it. The function is the "cin.fail()", where it returns true if the input fails. In my case, the input type was an integer, so if a non-integer type was inputted, it would be categorized as a failed input. If the input failed, the "cin.clear()" was used to clear the error state of the buffer, so that the future inputs can be put into it. Finally, the "cin.ignore" was implemented to ignore the rest of the line after the instance of the error and it skips to the next line. Overloading operators were used in Milestone 1 and it was a similar concept to the previous workshop that I have worked on. Some examples of the overloading operators were "Time& operator-=(const Time& D);" and "Time operator-(const Time& D)const;". 

	While working on the workshop and the milestone, I have faced few difficulties. In the workshop, I had trouble finding and understanding how the derivation worked within the classes and implementing it in the workshop. However, through reading the lecture notes and the recorded lectures, I was able to understand the basics of it. Then my testing out the code that was worked within the lectures, I was able to grasp the idea of how to use it. In the milestone, I had trouble finding an efficient way of accepting the inputs and checking if the input was acceptable or not. Through searching online, I was able to find the method mentioned above. Another difficulty was finding a correct algorithm for calculating the time, where different cases could occur. However, after several trials and errors, I was able to find it. Therefore, these were what I have learned through the workshop and the milestone and what I had difficulties on. 